Diff ways to create Bean in java?
1.Annotation Based:
Mark the class with @Component, @Service ,@Repository, @Controller, @RestController.
@Service: mark it on class which has business logic.
@Repository: mark it on class which interacts with the repository.
@RestController: mark it on class which has endpoints.
@Component: It is equal to @Service ,@Repository. but mark it on the classes which has does not business logic.

2.Java Based:
if we want to create any object manually and register this inside the container.
step1: annotate the class with @Configuration(This tells to spring that this class has beans)
step2: create any method that should required bean and mark that method with @Bean.
       By this we can get full control over the object creation.

3.XML Based : we need to create xml files and configure beans inside the xml.


IOC Container:

The IoC container in Spring is responsible for managing the lifecycle and dependencies of beans (Java objects). It follows the Inversion of Control principle, where the control of object creation and dependency management is shifted from the application to the container.
Types of IOC Container:
Total two types of IOC container.
1.BeanFactory(Interface): It is basic IOC Container.
It is a container where object creation and managing and destruction is done here.
It is a basic container used in small application.
It is lazy loading: It means it creates objects when it is requested.

2.ApplicationContext(Interface): It is advance IOC Container, it supports Internationalization(i18).
It is an container where object creation and managing and destruction(life cycle) is done here.
It is an advance container used in large application.
it is eager loading: It means it creates objects at the time of application starts.

In ApplicationContext during the application start, all beans are created inside the IOC container.
But in BeaFactory the beans are created while it is requested or when it is accessed.

All the beans inside the container created with camelcase.
Example: ClassName: UserServiceImpl ->BeanName: userServiceImpl.

Scope:In Spring Boot, bean scope determines how a bean is created, shared, and managed within the application context.
By default, all beans in spring boot are singleton.
It means wherever you request a particular object, it returns the same object from container.

If we want to change the scope of any bean, we need to annotate the @Scope("Mention scope name")
Example: @Scope("prototype")
Prototype: Means on every request a new object is created and shared.

@Scope("request") : Creates a new bean of the bean for each HTTP request.

@Scope("session") : Creates a new bean per user session.

 @Bean(name = "restTemplateObject")
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
In Spring, when you declare a @Bean method without explicitly providing a name, the default bean name is the method name itself.
That’s what will be registered in the IoC container, unless you override it with:
@Bean(name = "customRestTemplate")
By default, when you declare a @Bean in a Spring @Configuration class, its scope is: singleton


How to do get know where an annotation is applicable?
We can get know by using this annotation on our annotation:
@Target({ElementType.TYPE, ElementType.METHOD})

Based On ElementType: We get know..
TYPE: On class or interface.
METHOD: On method
FIELD: On field.
PARAMETER: method argument
CONSTRUCTOR: On CONSTRUCTOR
LOCAL_VARIABLE: in local variable
ANNOTATION_TYPE: on annotation


standard RetentionPolicy enum from the Java Reflection API (java.lang.annotation.RetentionPolicy).

Here’s what each constant means in practice:

1.SOURCE
The annotation exists only in source code.
The compiler discards it during compilation.
Example: @Override → it’s only for the compiler to check, doesn’t go into the .class file.

2.CLASS (default if not specified)
The annotation is written into the .class file by the compiler.
The JVM does not retain it at runtime, so reflection cannot see it.
Useful for tools like bytecode analyzers.

3.RUNTIME
The annotation is stored in the .class file and retained by the JVM at runtime.
This allows frameworks and libraries (like Spring, JUnit, Hibernate, etc.) to access annotations through reflection.
Example: @Autowired, @Test.

